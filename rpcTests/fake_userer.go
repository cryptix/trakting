// This file was generated by counterfeiter
package rpcTests

import (
	"sync"

	"github.com/cryptix/trakting/types"
)

type FakeUserer struct {
	AddStub        func(name, passw string, level int) error
	addMutex       sync.RWMutex
	addArgsForCall []struct {
		name  string
		passw string
		level int
	}
	addReturns struct {
		result1 error
	}
	ChangePasswordStub        func(id int64, newpw string) error
	changePasswordMutex       sync.RWMutex
	changePasswordArgsForCall []struct {
		id    int64
		newpw string
	}
	changePasswordReturns struct {
		result1 error
	}
	CurrentStub        func() (*types.User, error)
	currentMutex       sync.RWMutex
	currentArgsForCall []struct{}
	currentReturns struct {
		result1 *types.User
		result2 error
	}
	ListStub        func() ([]types.User, error)
	listMutex       sync.RWMutex
	listArgsForCall []struct{}
	listReturns struct {
		result1 []types.User
		result2 error
	}
	CheckStub        func(user, pass string) (interface{}, error)
	checkMutex       sync.RWMutex
	checkArgsForCall []struct {
		user string
		pass string
	}
	checkReturns struct {
		result1 interface{}
		result2 error
	}
}

func (fake *FakeUserer) Add(name string, passw string, level int) error {
	fake.addMutex.Lock()
	fake.addArgsForCall = append(fake.addArgsForCall, struct {
		name  string
		passw string
		level int
	}{name, passw, level})
	fake.addMutex.Unlock()
	if fake.AddStub != nil {
		return fake.AddStub(name, passw, level)
	} else {
		return fake.addReturns.result1
	}
}

func (fake *FakeUserer) AddCallCount() int {
	fake.addMutex.RLock()
	defer fake.addMutex.RUnlock()
	return len(fake.addArgsForCall)
}

func (fake *FakeUserer) AddArgsForCall(i int) (string, string, int) {
	fake.addMutex.RLock()
	defer fake.addMutex.RUnlock()
	return fake.addArgsForCall[i].name, fake.addArgsForCall[i].passw, fake.addArgsForCall[i].level
}

func (fake *FakeUserer) AddReturns(result1 error) {
	fake.AddStub = nil
	fake.addReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserer) ChangePassword(id int64, newpw string) error {
	fake.changePasswordMutex.Lock()
	fake.changePasswordArgsForCall = append(fake.changePasswordArgsForCall, struct {
		id    int64
		newpw string
	}{id, newpw})
	fake.changePasswordMutex.Unlock()
	if fake.ChangePasswordStub != nil {
		return fake.ChangePasswordStub(id, newpw)
	} else {
		return fake.changePasswordReturns.result1
	}
}

func (fake *FakeUserer) ChangePasswordCallCount() int {
	fake.changePasswordMutex.RLock()
	defer fake.changePasswordMutex.RUnlock()
	return len(fake.changePasswordArgsForCall)
}

func (fake *FakeUserer) ChangePasswordArgsForCall(i int) (int64, string) {
	fake.changePasswordMutex.RLock()
	defer fake.changePasswordMutex.RUnlock()
	return fake.changePasswordArgsForCall[i].id, fake.changePasswordArgsForCall[i].newpw
}

func (fake *FakeUserer) ChangePasswordReturns(result1 error) {
	fake.ChangePasswordStub = nil
	fake.changePasswordReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserer) Current() (*types.User, error) {
	fake.currentMutex.Lock()
	fake.currentArgsForCall = append(fake.currentArgsForCall, struct{}{})
	fake.currentMutex.Unlock()
	if fake.CurrentStub != nil {
		return fake.CurrentStub()
	} else {
		return fake.currentReturns.result1, fake.currentReturns.result2
	}
}

func (fake *FakeUserer) CurrentCallCount() int {
	fake.currentMutex.RLock()
	defer fake.currentMutex.RUnlock()
	return len(fake.currentArgsForCall)
}

func (fake *FakeUserer) CurrentReturns(result1 *types.User, result2 error) {
	fake.CurrentStub = nil
	fake.currentReturns = struct {
		result1 *types.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserer) List() ([]types.User, error) {
	fake.listMutex.Lock()
	fake.listArgsForCall = append(fake.listArgsForCall, struct{}{})
	fake.listMutex.Unlock()
	if fake.ListStub != nil {
		return fake.ListStub()
	} else {
		return fake.listReturns.result1, fake.listReturns.result2
	}
}

func (fake *FakeUserer) ListCallCount() int {
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	return len(fake.listArgsForCall)
}

func (fake *FakeUserer) ListReturns(result1 []types.User, result2 error) {
	fake.ListStub = nil
	fake.listReturns = struct {
		result1 []types.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserer) Check(user string, pass string) (interface{}, error) {
	fake.checkMutex.Lock()
	fake.checkArgsForCall = append(fake.checkArgsForCall, struct {
		user string
		pass string
	}{user, pass})
	fake.checkMutex.Unlock()
	if fake.CheckStub != nil {
		return fake.CheckStub(user, pass)
	} else {
		return fake.checkReturns.result1, fake.checkReturns.result2
	}
}

func (fake *FakeUserer) CheckCallCount() int {
	fake.checkMutex.RLock()
	defer fake.checkMutex.RUnlock()
	return len(fake.checkArgsForCall)
}

func (fake *FakeUserer) CheckArgsForCall(i int) (string, string) {
	fake.checkMutex.RLock()
	defer fake.checkMutex.RUnlock()
	return fake.checkArgsForCall[i].user, fake.checkArgsForCall[i].pass
}

func (fake *FakeUserer) CheckReturns(result1 interface{}, result2 error) {
	fake.CheckStub = nil
	fake.checkReturns = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

var _ types.Userer = new(FakeUserer)
